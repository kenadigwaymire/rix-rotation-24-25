{"path":"PS1solutions.pdf","text":"ACM/IDS 104 APPLIED LINEAR ALGEBRA PROBLEM SET 1: SOLUTIONS KONSTANTIN M. ZUEV Problem 1. (10 points) Matrix Multiplication Let A ∈ Mm×p and B ∈ Mp×n be m × p and p × n matrices respectively. Then, by deﬁnition, the (i, j) entry of C = AB is the dot product of the i th row of A and the jth column of B: cij = ai · bj = p∑ k=1 aikbkj. (1) Interestingly, we can also compute AB by multiplying columns of A by rows of B. Show that AB = p∑ k=1 akb k, (2) where each term akbk is a matrix of size m × n. In particular, if B is a column vector B = x ∈ Rp, then Ax = p∑ k=1 xkak. (3) is a linear combination of columns of A. We will make use of this interpretation of matrix multiplication in the lectures. Remark: Decomposition (2) is related to the notion of outer product (also called tensor product) of two vectors. If u, v ∈ Rp are two (column) vectors, then their outer product is deﬁned as u ⊗ v = uvT ∈ Mp×p. (4) Solution: Let’s show that the (i, j) entry ( ∑p k=1 akb k)ij of matrix ∑p k=1 akbk coincides with cij = ∑p k=1 aikbkj. This would justify (2). By deﬁnition of matrix addition, ( p∑ k=1 akbk) ij = p∑ k=1 (akb k)ij. (5) Let’s look at the (i, j) entry (akb k)ij of the kth matrix akbk. It is the i th entry of the column vector ak multiplied by the jth entry of the row vector bk, that is (akbk)ij = aikbkj. Therefore, ( p∑ k=1 akb k) ij = p∑ k=1 aikbkj = cij. (6) Problem 2. (10 points) Nilpotent Matrices In lecture 1, we saw that A2 = 0 does not imply A = 0. This motivates the following deﬁnition: a square matrix A ∈ Mn×n is called nilpotent if Ak = 0 for some k ≥ 1. Show that any strictly upper triangular matrix (that is upper triangular with zero diagonal) is nilpotent. E-mail address: kostia@caltech.edu. 1 2 ACM/IDS 104 APPLIED LINEAR ALGEBRA PROBLEM SET 1: SOLUTIONS Solution: Let’s show by induction on the matrix size n that An = 0. For a 2-by-2 matrix this is easy to check: [ 0 a 0 0 ] · [ 0 a 0 0 ] = [ 0 0 0 0 ] (7) Assume that for any strictly upper triangular matrix of size (n − 1) × (n − 1), An−1 = 0. Let us now show that this implies that for any strictly upper triangular matrix A of size n × n, An = 0 (this would complete the induction argument). We can view A as a block matrix: A = [ An−1 an−1 0T n−1 0 ] , (8) where block An−1 is a block of of size (n − 1) × (n − 1), an−1 is a column vector of size (n − 1), 0 T n−1 is a zero row vector of size (n − 1), and 0 is simply the entry ann (which is zero). Note that An−1 is a strictly upper triangular matrix of size (n − 1) × (n − 1), and thus, by induction assumption, strictly upper triangular matrix of size An−1 n−1 = 0. We can compute the kth power of A explicitly: A2 = [An−1 an−1 0 T n−1 0 ] · [ An−1 an−1 0 T n−1 0 ] = [ A2 n−1 An−1an−1 0 T n−1 0 ] A3 = [ A2 n−1 An−1an−1 0 T n−1 0 ] · [ An−1 an−1 0 T n−1 0 ] = [ A3 n−1 A2 n−1an−1 0 T n−1 0 ] . . . Ak = [ Ak n−1 Ak−1 n−1an−1 0 T n−1 0 ] (9) And, thus, An = 0. Problem 3. (10 points) Permuted LU Factorization Let An be the n × n tridiagonal matrix with all 2’s along the main diagonal, and all −1’s along the sub- and super-diagonals1. Find the factors Pn, Ln, and Un in the permuted LU factorization of An: PnAn = LnUn. (10) Hint: You can compute the PLU factorization of An in MATLAB for diﬀerent (large) values of n and check how Pn, Ln, and Un look like. Formulate a hypothesis (a “guess”) for Pn, Ln, and Un from your observations, and then prove it. Solution: To ﬁnd a pattern, you can use MATLAB code similar to below. size=10; I=2*eye(size); for i=1:size-1 I(i,i+1)=-1; I(i+1,i)=-1; end [L,U,P]=lu(I) The pattern you should notice is Pn = In, Ln =        1 0 . . . 0 0 − 1 2 1 . . . 0 0 ... . . . ... 0 0 . . . 1 0 0 0 . . . − n−1 n 1        , Un =        2 −1 . . . 0 0 0 3 2 . . . 0 0 ... . . . ... 0 0 . . . n n−1 −1 0 0 . . . 0 n+1 n        (11) 1Recall that An is the coeﬃcient matrix of a linear system which is obtained from discretization of the Poisson equation in 1D, see lecture 1. ACM/IDS 104 APPLIED LINEAR ALGEBRA PROBLEM SET 1: SOLUTIONS 3 It is now straightforward to check that indeed An = LnUn. Problem 4. (10 points) Orthogonal Matrices The Gaussian elimination method results into the permuted LU decomposition, P A = LU , which is fundamental for solving linear systems. Another important factorization of a nonsingular matrix is the so-called QR factorization (will discuss in lectures), which can also be used for solving square linear systems (this approach is more computationally expensive, but less prone to inaccuracies and more numerically stable). The QR factorization is based on the notion of orthogonal matrix. A square matrix A is called orthogonal if its inverse and transpose are coincide: A−1 = AT . (a) (5 points) Show that any permutation matrix P is orthogonal. (b) (5 points) Is an orthogonal matrix necessarily a permutation matrix? Solution: (a) A matrix is orthogonal if QQ T = I. We thus want to show that P P T = I. Let’s compute the (i, j) entry of P P T : (P P T )ij = n∑ k=1 Pik(P T )kj = n∑ k=1 PikPjk = {0 i ̸= j 1 i = j (12) The last equality is because every row and column in a permutation matrix contains exactly one 1 and all the other elements are 0. For the identity matrix: Iij = {0 i ̸= j 1 i = j (13) We therefore have P P T = I and P is orthogonal. (b) No. For example, the matrix R = [cos θ − sin θ sin θ cos θ ] (14) is not a permutation matrix, but RRT = [ cos θ − sin θ sin θ cos θ ] [ cos θ sin θ − sin θ cos θ ] = [ 1 0 0 1 ] = I. (15) Problem 5. (10 points) Skew-Symmetric Matrices In lecture 2, we discussed symmetric matrices and their properties. Another important class of matrices is skew-symmetric matrices. A matrix A is skew-symmetric if AT = −A. Show that every square matrix A can be written as a sum of a symmetric matrix S and a skew-symmetric matrix J: A = S + J, ST = S, J T = −J. (16) Solution: For any square matrix A, A = A + AT 2| {z } S + A − AT 2| {z } J . (17) It is easy to check that S is symmetric and J is skew-symmetric. Problem 6. (10 points) Determinants are Expensive to Compute. Complete Problem 6 in PS1.mlx. Solution: See PS1solutions.mlx (uploaded to the Piazza page). 4 ACM/IDS 104 APPLIED LINEAR ALGEBRA PROBLEM SET 1: SOLUTIONS Problem 7. (10 points) Solving Linear Systems Let B be the following n × n matrix: B =      1 2 . . . n n + 1 n + 2 . . . 2n ... ... ... n2 − n + 1 n2 − n + 2 . . . n2      (18) (a) (5 points) Find the rank of B and complete Problem 7a in PS1.mlx. Remark: You don’t need MATLAB to ﬁnd the answer, but you can use it for making the right guess. We have provided a way of checking your answer in Problem 7a of PS1.mlx. In your solutions, please explain why your answer is correct for any n, and not only the values explored in MATLAB. (b) (5 points) Complete Problem 7b in PS1.mlx. Remeber to report the non-zero components in your solutions. Solution: Part (a): We know (a corollary of the fundamental theorem, see lecture 4) that the rank of a matrix is the dimension of its “row space,” i.e. a subspace spanned by its rows. Let a i be the ith row of A. The ﬁrst two rows form a basis of span(a 1, . . . , an). Indeed, they are linearly independent and a k = a 1 + (k − 1)(a 2 − a 1), k = 1, . . . , n. (19) See PS1solutions.mlx (uploaded to the Piazza page). Part (b): See PS1solutions.mlx (uploaded to the Piazza page). Acknowledgements. A huge thanks to Pavlos Stavrinides for editing my clumsy MATLAB m-ﬁles and converting them into neat live scripts! ACM/IDS 104 - Problem Set 1- MATLAB Solutions Before writing your MATLAB code, it is always good practice to get rid of any leftover variables and figures from previous scripts. clc; clear; close all; NOTE: As this is the first problem set (and many of you might be unfamiliar with MATLAB) we will provide some helper code. As the term progresses (and you become more experienced) we will omit this. Problem 6 (10 points) Determinants are Expensive to Compute In lecture 2, we discussed that computing determinants is a computationally expensive task. Let's see how long it takes MATLAB to compute determinants of large matrices (MATLAB uses LU factorization, not the Leibniz formula of course). To do this, we will: 1. Generate 25 values of n log-spaces between and . 2. For each generate a matrix A of size with entries being sampled from the standard normal distribution. Use . 3. Compute and measure the time MATLAB took to complete the computatation. Use and . 4. Plot the times versus the values of n in the log-log scale. Label the axes and give a meaningful plot title. % Setup is completed for you; make sure you understand what is happening vals = 25; n_vals = floor(logspace(2, 4, vals)); times = NaN(vals, 1); % TODO for i = 1 : vals % Define n as the i-th element of the n_vals array n = n_vals(i); % Create the matrix A as described in step 2 A = randn(n); tic; % This tells MATLAB to start the timer % Compute the determinant of A det(A); times(i) = toc; % This tells MATLAB to stop the timer and store the time end %{ PLOTTING Here is an elementary example of how to plot in MATLAB. Feel free to explore and customize your plots to make them more attractive! %} 1 figure; % Always tell MATLAB you are starting a new figure loglog(n_vals, times, \"b\", \"LineWidth\", 2); % log-log scale plot xlabel(\"Size of square matrix\"); ylabel(\"Seconds taken to compute determinant\"); title(\"Determinants are expensive to compute\"); Problem 7 (10 points) Solving Linear Systems We have the matrix: Part (a) (5 points) In this part, your task is to find . As mentioned in the problem set, MATLAB is not needed to obtain the answer. However, we can use MATLAB to make a right guess and check our answer. To do this, we first need to construct matrix B in MATLAB: NOTE: Although you can check your answer here, you still need to justify and show your reasoning to obtain full credit :) n = 100; % set n as specified in Part (b) B = 1 : n; for i = 2 : n % TODO (one-liner) 2 B(i, :) = B(i - 1, :) + n; end r = rank(B); % check your answer here Part (b) (5 points) Set and consider the system of linear equations where . Find a solution x such that its first components are zero. What are the non-zero components of x? HINT: The backslash operator issues a warning if B is nearly singular and raises an error condition if it detects exact singularity. In that case, use for finding a particular solution of . The function returns the \"pseudoinverse\" of B (will discuss the Moore-Penrose pseudoinverse in lecture 16). Also, the following built-in function may be useful: . %{ Let us start by defining the column vector c as specified above. Remember that in MATLAB we can use ' to transpose a vector. %} c = [1 : n]'; %{ Now, we obtain a particular solution as described above %} x_0 = pinv(B) * c; %{ Use null(B) to define a matrix whose columns form an orthonormal basis in the vector space of all solution of the homogeneous system Bx=0. %} V = null(B); %{ Use the rank, r, found in part (a) to define k = n - rank(B). This is the number of free variables / dimension of the vector space. %} k = n - r; This is a good point to review what we have done so far. Recall that the desired solution of the system is: where α is a vector. We can obtain α by solving the system: %{ Find alpha by solving the described system (**). -> Hint1: Remeber that alpha is a k*1 vector. Hence, you need to restrict the sizes of x_0 and V 3 -> Hint2: Use backslash %} alpha = - V(1 : k, :) \\ x_0(1 : k); %{ Finally, put everything together and find x using (*) %} x = x_0 + V*alpha; disp(x); -0.0000 0.0000 0.0000 0.0000 -0.0000 -0.0000 0.0000 -0.0000 0.0000 0.0000 -0.0000 -0.0000 -0.0000 0.0000 -0.0000 0.0000 -0.0000 -0.0000 0.0000 0.0000 -0.0000 0.0000 0.0000 -0.0000 0.0000 -0.0000 0.0000 0.0000 0.0000 -0.0000 0.0000 -0.0000 -0.0000 0.0000 0.0000 -0.0000 0.0000 -0.0000 0.0000 -0.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0000 0.0000 0.0000 0.0000 -0.0000 0.0000 -0.0000 0.0000 0.0000 4 -0.0000 -0.0000 0.0000 -0.0000 0.0000 0.0000 -0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 -0.0000 0.0000 0.0000 0.0000 -0.0000 -0.0000 -0.0000 0 -0.0000 0.0000 0.0000 -0.0000 0.0000 0.0000 0.0000 -0.0000 -0.0000 0.0000 -0.0000 0.0000 -0.0000 -0.0000 -0.0000 0.0000 -0.0000 -0.0000 -0.0000 0.0000 -0.0000 -0.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0100 %{ Now, let us see how x compares to the actual solution. Un-comment the following 2 lines of code once you reach this part. %} error = norm(B*x - c); disp(error); 2.5502e-12 Don't forget to report the non-zero components of x! 5","libVersion":"0.2.3","langs":""}